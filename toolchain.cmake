#!/usr/bin/env cmake

# Mark variables as used so cmake doesn't complain about them
mark_as_advanced(CMAKE_TOOLCHAIN_FILE)

set(CONFIG_FATAL_ERROR)
set(CONFIG_HAS_FATAL_ERROR OFF)

function(add_fatal_error ERROR)
    if(NOT CONFIG_HAS_FATAL_ERROR)
        set(CONFIG_HAS_FATAL_ERROR ON PARENT_SCOPE)
        set(CONFIG_FATAL_ERROR "${ERROR}" PARENT_SCOPE)
    else()
        string(APPEND CONFIG_FATAL_ERROR "\n${ERROR}")
    endif()
endfunction()

set(CMAKE_REQUIRED_MINIMUM_VERSION "3.7.2")
if(CMAKE_VERSION VERSION_LESS CMAKE_REQUIRED_MINIMUM_VERSION)
    message(FATAL_ERROR "Toolchain requires at least CMake ${CMAKE_REQUIRED_MINIMUM_VERSION}.")
endif()
cmake_policy(PUSH)
cmake_policy(VERSION 3.7.2)

option(VERBOSE "Enables output while configuring." ON)
mark_as_advanced(VERBOSE)

if($ENV{VERBOSE})
    set(VERBOSE "$ENV{VERBOSE}")
else()
    set(VERBOSE ON)
endif()

option(APPLOCAL_DEPS "Automatically copy dependencies to output dir for executables (not functioning)." ON)
option(APPLOCAL_DEPS_SERIALIZED "Adds USES_TERMINAL to APPLOCAL_DEPS to force serialization." OFF)

if(NOT DEFINED TARGET_TRIPLET)
    message(STATUS "No TARGET_TRIPLET passed in during invocation. Using detected triplet...")
endif()

if(NOT DEFINED WINSDK_VERSION)
    if(DEFINED ENV{WindowsSDKVersion})
        if("$ENV{WindowsSDKVersion}" MATCHES [[^([0-9.]*)\\?$]])
            set(WINSDK_VERSION "$ENV{WindowsSDKVersion}" CACHE STRING "")
            message(STATUS "WINSDK_VERSION = ${WINSDK_VERSION}")
        else()
            message(FATAL_ERROR "Unexpected format for ENV{WindowsSDKVersion} ($ENV{WindowsSDKVersion})")
        endif()
    endif()
endif()


macro(function_arguments OUT_VAR)
    if("${ARGC}" EQUAL "1")
        set(function_arguments_FIRST_ARG "0")
    elseif("${ARGC}" EQUAL "2")
        set(function_arguments_FIRST_ARG "${ARGV1}")
    else()
        # bug
        message(FATAL_ERROR "function_arguments: invalid arguments (${ARGV})")
    endif()

    set("${OUT_VAR}" "")

    # this allows us to get the value of the enclosing function's ARGC
    set(function_arguments_ARGC_NAME "ARGC")
    set(function_arguments_ARGC "${${function_arguments_ARGC_NAME}}")

    math(EXPR function_arguments_LAST_ARG "${function_arguments_ARGC} - 1")
    if(function_arguments_LAST_ARG GREATER_EQUAL function_arguments_FIRST_ARG)
        foreach(function_arguments_N RANGE "${function_arguments_FIRST_ARG}" "${function_arguments_LAST_ARG}")
            string(REPLACE ";" "\\;" function_arguments_ESCAPED_ARG "${ARGV${function_arguments_N}}")
            # adds an extra `;` on the first time through
            set("${OUT_VAR}" "${${OUT_VAR}};${function_arguments_ESCAPED_ARG}")
        endforeach()
        # remove leading `;`
        string(SUBSTRING "${${OUT_VAR}}" "1" "-1" "${OUT_VAR}")
    endif()
endmacro()



#[===[.md:
# set_powershell_path

Gets either the path to powershell or powershell core,
and places it in the variable POWERSHELL_PATH.
#]===]
function(set_powershell_path)
    # Attempt to use pwsh if it is present; otherwise use powershell
    if(NOT DEFINED POWERSHELL_PATH)
        find_program(PWSH_PATH pwsh)
        if(PWSH_PATH)
            set(POWERSHELL_PATH "${PWSH_PATH}" CACHE INTERNAL "The path to the PowerShell implementation to use.")
        else()
            message(DEBUG "Could not find PowerShell Core; falling back to PowerShell")
            find_program(BUILTIN_POWERSHELL_PATH powershell REQUIRED)
            if(BUILTIN_POWERSHELL_PATH)
                set(POWERSHELL_PATH "${BUILTIN_POWERSHELL_PATH}" CACHE INTERNAL "The path to the PowerShell implementation to use.")
            else()
                message(WARNING "Could not find PowerShell; using static string 'powershell.exe'")
                set(POWERSHELL_PATH "powershell.exe" CACHE INTERNAL "The path to the PowerShell implementation to use.")
            endif()
        endif()
    endif() # POWERSHELL_PATH
endfunction()

if(TARGET_IS_MINGW)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/mingw.cmake")
    if(NOT _MINGW_TOOLCHAIN)
        set(_MINGW_TOOLCHAIN 1)
        message(STATUS "Loading toolchain: MinGW")
        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
            set(CMAKE_CROSSCOMPILING OFF CACHE BOOL "")
        endif()

        # Need to override MinGW from VCPKG_CMAKE_SYSTEM_NAME
        set(CMAKE_SYSTEM_NAME Windows CACHE STRING "" FORCE)

        if(TARGET_TRIPLET_ARCH STREQUAL "x86")
            set(CMAKE_SYSTEM_PROCESSOR i686 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "x64")
            set(CMAKE_SYSTEM_PROCESSOR x86_64 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm")
            set(CMAKE_SYSTEM_PROCESSOR armv7 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm64")
            set(CMAKE_SYSTEM_PROCESSOR aarch64 CACHE STRING "")
        endif()

        foreach(lang C CXX)
            set(CMAKE_${lang}_COMPILER_TARGET "${CMAKE_SYSTEM_PROCESSOR}-windows-gnu" CACHE STRING "")
        endforeach()

        find_program(CMAKE_C_COMPILER "${CMAKE_SYSTEM_PROCESSOR}-w64-mingw32-gcc")
        find_program(CMAKE_CXX_COMPILER "${CMAKE_SYSTEM_PROCESSOR}-w64-mingw32-g++")
        find_program(CMAKE_RC_COMPILER "${CMAKE_SYSTEM_PROCESSOR}-w64-mingw32-windres")
        if(NOT CMAKE_RC_COMPILER)
            find_program(CMAKE_RC_COMPILER "windres")
        endif()

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS_INIT " ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS_INIT " ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG_INIT " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG_INIT " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE_INIT " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE_INIT " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            if(CRT_LINKAGE STREQUAL "static")
                string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT "-static ")
                string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT "-static ")
            endif()
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif()
    endif()
elseif(TARGET_IS_XBOX)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/xbox.cmake")
    message(STATUS "Loading toolchain: XBox")
elseif(TARGET_IS_UWP)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/uwp.cmake")
    message(STATUS "Loading toolchain: UWP")
elseif(TARGET_IS_WINDOWS) # This is also true for MinGW and UWP targets, so place it after those...
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/windows.cmake")
    if(NOT _WINDOWS_TOOLCHAIN)
        set(_WINDOWS_TOOLCHAIN 1)
        message(STATUS "Loading toolchain: Windows")
        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>$<$<STREQUAL:${CRT_LINKAGE},dynamic>:DLL>" CACHE STRING "Select the MSVC runtime library for use by compilers targeting the MSVC ABI.")

        set(CMAKE_SYSTEM_NAME Windows CACHE STRING "")

        if(TARGET_TRIPLET_ARCH STREQUAL "x86")
            set(CMAKE_SYSTEM_PROCESSOR x86 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "x64")
            set(CMAKE_SYSTEM_PROCESSOR AMD64 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm")
            set(CMAKE_SYSTEM_PROCESSOR ARM CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm64")
            set(CMAKE_SYSTEM_PROCESSOR ARM64 CACHE STRING "")
        endif()

        if(DEFINED CMAKE_SYSTEM_VERSION)
            set(CMAKE_SYSTEM_VERSION "${CMAKE_SYSTEM_VERSION}" CACHE STRING "The version of the operating system for which CMake is to build." FORCE)
        endif()

        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
            if(CMAKE_SYSTEM_PROCESSOR STREQUAL CMAKE_HOST_SYSTEM_PROCESSOR)
                set(CMAKE_CROSSCOMPILING OFF CACHE STRING "Intended to indicate whether CMake is cross compiling, but note limitations discussed below.")
            elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "x86")
                # any of the four platforms can run x86 binaries
                set(CMAKE_CROSSCOMPILING OFF CACHE STRING "")
            elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "ARM64")
                # arm64 can run binaries of any of the four platforms after Windows 11
                set(CMAKE_CROSSCOMPILING OFF CACHE STRING "Intended to indicate whether CMake is cross compiling, but note limitations discussed below.")
            endif()

            if(NOT DEFINED CMAKE_SYSTEM_VERSION)
                set(CMAKE_SYSTEM_VERSION "${CMAKE_HOST_SYSTEM_VERSION}" CACHE STRING "The version of the operating system for which CMake is to build.")
            endif()
        endif()

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)

            if(CRT_LINKAGE STREQUAL "dynamic")
                set(CRT_LINK_FLAG_PREFIX "/MD")
            elseif(CRT_LINKAGE STREQUAL "static")
                set(CRT_LINK_FLAG_PREFIX "/MT")
            else()
                message(FATAL_ERROR "Invalid setting for CRT_LINKAGE: \"${CRT_LINKAGE}\". It must be \"static\" or \"dynamic\"")
            endif()

            set(CHARSET_FLAG "/utf-8")
            if (NOT SET_CHARSET_FLAG OR PLATFORM_TOOLSET MATCHES "v120")
                # VS 2013 does not support /utf-8
                set(CHARSET_FLAG)
            endif()

            set(MP_BUILD_FLAG "")
            if(NOT (CMAKE_CXX_COMPILER MATCHES "clang-cl.exe"))
                set(MP_BUILD_FLAG "/MP")
            endif()

            set(CMAKE_CXX_FLAGS " /nologo /DWIN32 /D_WINDOWS /W3 ${CHARSET_FLAG} /GR /EHsc ${MP_BUILD_FLAG} ${VCPKG_CXX_FLAGS}" CACHE STRING "")
            set(CMAKE_C_FLAGS " /nologo /DWIN32 /D_WINDOWS /W3 ${CHARSET_FLAG} ${MP_BUILD_FLAG} ${VCPKG_C_FLAGS}" CACHE STRING "")

            if(TARGET_TRIPLET_ARCH STREQUAL "arm64ec")
                string(APPEND CMAKE_CXX_FLAGS " /arm64EC /D_AMD64_ /DAMD64 /D_ARM64EC_ /DARM64EC")
                string(APPEND CMAKE_C_FLAGS " /arm64EC /D_AMD64_ /DAMD64 /D_ARM64EC_ /DARM64EC")
            endif()
            set(CMAKE_RC_FLAGS "-c65001 /DWIN32" CACHE STRING "RC flags for all build types.")

            unset(CHARSET_FLAG)

            set(CMAKE_CXX_FLAGS_DEBUG "/D_DEBUG ${CRT_LINK_FLAG_PREFIX}d /Z7 /Ob0 /Od /RTC1 ${VCPKG_CXX_FLAGS_DEBUG}" CACHE STRING "")
            set(CMAKE_C_FLAGS_DEBUG "/D_DEBUG ${CRT_LINK_FLAG_PREFIX}d /Z7 /Ob0 /Od /RTC1 ${VCPKG_C_FLAGS_DEBUG}" CACHE STRING "")
            set(CMAKE_CXX_FLAGS_RELEASE "${CRT_LINK_FLAG_PREFIX} /O2 /Oi /Gy /DNDEBUG /Z7 ${VCPKG_CXX_FLAGS_RELEASE}" CACHE STRING "")
            set(CMAKE_C_FLAGS_RELEASE "${CRT_LINK_FLAG_PREFIX} /O2 /Oi /Gy /DNDEBUG /Z7 ${VCPKG_C_FLAGS_RELEASE}" CACHE STRING "")

            string(APPEND CMAKE_STATIC_LINKER_FLAGS_RELEASE_INIT " /nologo ")
            set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "/nologo /DEBUG /INCREMENTAL:NO /OPT:REF /OPT:ICF ${VCPKG_LINKER_FLAGS} ${VCPKG_LINKER_FLAGS_RELEASE}" CACHE STRING "")
            set(CMAKE_EXE_LINKER_FLAGS_RELEASE "/nologo /DEBUG /INCREMENTAL:NO /OPT:REF /OPT:ICF ${VCPKG_LINKER_FLAGS} ${VCPKG_LINKER_FLAGS_RELEASE}" CACHE STRING "")

            string(APPEND CMAKE_STATIC_LINKER_FLAGS_DEBUG_INIT " /nologo ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " /nologo ${VCPKG_LINKER_FLAGS} ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " /nologo ${VCPKG_LINKER_FLAGS} ${VCPKG_LINKER_FLAGS_DEBUG} ")
        endif()
    endif()

elseif(TARGET_IS_LINUX)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/linux.cmake")
    message(STATUS "Loading toolchain: Linux")
    if(NOT _LINUX_TOOLCHAIN)
        set(_LINUX_TOOLCHAIN 1)
        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
            set(CMAKE_CROSSCOMPILING OFF CACHE BOOL "")
        endif()
        set(CMAKE_SYSTEM_NAME Linux CACHE STRING "")
        if(TARGET_TRIPLET_ARCH STREQUAL "x64")
            set(CMAKE_SYSTEM_PROCESSOR x86_64 CACHE STRING "")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "x86")
            set(CMAKE_SYSTEM_PROCESSOR x86 CACHE STRING "")
            string(APPEND VCPKG_C_FLAGS " -m32")
            string(APPEND VCPKG_CXX_FLAGS " -m32")
            string(APPEND VCPKG_LINKER_FLAGS " -m32")
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm")
            set(CMAKE_SYSTEM_PROCESSOR armv7l CACHE STRING "")
            if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux" AND CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x86_64")
                if(NOT DEFINED CMAKE_CXX_COMPILER)
                    set(CMAKE_CXX_COMPILER "arm-linux-gnueabihf-g++")
                endif()
                if(NOT DEFINED CMAKE_C_COMPILER)
                    set(CMAKE_C_COMPILER "arm-linux-gnueabihf-gcc")
                endif()
                if(NOT DEFINED CMAKE_ASM_COMPILER)
                    set(CMAKE_ASM_COMPILER "arm-linux-gnueabihf-gcc")
                endif()
                if(NOT DEFINED CMAKE_ASM-ATT_COMPILER)
                    set(CMAKE_ASM-ATT_COMPILER "arm-linux-gnueabihf-as")
                endif()
                message(STATUS "Cross compiling arm on host x86_64, use cross compiler: ${CMAKE_CXX_COMPILER}/${CMAKE_C_COMPILER}")
            endif()
        elseif(TARGET_TRIPLET_ARCH STREQUAL "arm64")
            set(CMAKE_SYSTEM_PROCESSOR aarch64 CACHE STRING "")
            if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux"  AND CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x86_64")
                if(NOT DEFINED CMAKE_CXX_COMPILER)
                    set(CMAKE_CXX_COMPILER "aarch64-linux-gnu-g++")
                endif()
                if(NOT DEFINED CMAKE_C_COMPILER)
                    set(CMAKE_C_COMPILER "aarch64-linux-gnu-gcc")
                endif()
                if(NOT DEFINED CMAKE_ASM_COMPILER)
                    set(CMAKE_ASM_COMPILER "aarch64-linux-gnu-gcc")
                endif()
                if(NOT DEFINED CMAKE_ASM-ATT_COMPILER)
                    set(CMAKE_ASM-ATT_COMPILER "aarch64-linux-gnu-as")
                endif()
                message(STATUS "Cross compiling arm64 on host x86_64, use cross compiler: ${CMAKE_CXX_COMPILER}/${CMAKE_C_COMPILER}")
            endif()
        endif()

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS_INIT " -fPIC ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS_INIT " -fPIC ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG_INIT " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG_INIT " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE_INIT " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE_INIT " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            if(VCPKG_CRT_LINKAGE STREQUAL "static")
                string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT "-static ")
                string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT "-static ")
            endif()
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif()
    endif()

elseif(TARGET_IS_ANDROID)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/android.cmake")
    set(ANDROID_CPP_FEATURES "rtti exceptions" CACHE STRING "")
    set(CMAKE_SYSTEM_NAME Android CACHE STRING "")
    set(ANDROID_TOOLCHAIN clang CACHE STRING "")
    set(ANDROID_NATIVE_API_LEVEL ${CMAKE_SYSTEM_VERSION} CACHE STRING "")
    if(CMAKE_SYSTEM_VERSION MATCHES "^[0-9]+$")
        set(ANDROID_PLATFORM android-${CMAKE_SYSTEM_VERSION} CACHE STRING "")
    else()
        set(ANDROID_PLATFORM ${CMAKE_SYSTEM_VERSION} CACHE STRING "")
    endif()
    set(CMAKE_ANDROID_NDK_TOOLCHAIN_VERSION clang CACHE STRING "")

    if (CRT_LINKAGE STREQUAL "dynamic")
        set(ANDROID_STL c++_shared CACHE STRING "")
    else()
        set(ANDROID_STL c++_static CACHE STRING "")
    endif()

    if(DEFINED ENV{ANDROID_NDK_HOME})
        set(ANDROID_NDK_HOME $ENV{ANDROID_NDK_HOME})
    else()
        set(ANDROID_NDK_HOME "$ENV{ProgramData}/Microsoft/AndroidNDK64/android-ndk-r13b/")
        if(NOT EXISTS "${ANDROID_NDK_HOME}")
            # Use Xamarin default installation folder
            set(ANDROID_NDK_HOME "$ENV{ProgramFiles\(x86\)}/Android/android-sdk/ndk-bundle")
        endif()
    endif()

    if(NOT EXISTS "${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake")
        message(FATAL_ERROR "Could not find android ndk. Searched at ${ANDROID_NDK_HOME}")
    endif()

    include("${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake")

    if(NOT _VCPKG_ANDROID_TOOLCHAIN)
        set(_VCPKG_ANDROID_TOOLCHAIN 1)
        message(STATUS "Loading toolchain: Android")
        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS " -fPIC ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS " -fPIC ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif()
    endif()
elseif(TARGET_IS_OSX)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/osx.cmake")
    if(NOT _OSX_TOOLCHAIN)
        set(_OSX_TOOLCHAIN 1)
        message(STATUS "Loading toolchain: OSX")

        set(CMAKE_SYSTEM_NAME Darwin CACHE STRING "")

        set(CMAKE_MACOSX_RPATH ON CACHE BOOL "")

        if(NOT DEFINED CMAKE_SYSTEM_PROCESSOR)
            if(TARGET_TRIPLET_ARCH STREQUAL "x64")
                set(CMAKE_SYSTEM_PROCESSOR x86_64 CACHE STRING "When not cross-compiling, this variable has the same value as the ``CMAKE_HOST_SYSTEM_PROCESSOR`` variable.")
            elseif(TARGET_TRIPLET_ARCH STREQUAL "x86")
                set(CMAKE_SYSTEM_PROCESSOR x86 CACHE STRING "When not cross-compiling, this variable has the same value as the ``CMAKE_HOST_SYSTEM_PROCESSOR`` variable.")
            elseif(TARGET_TRIPLET_ARCH STREQUAL "arm64")
                set(CMAKE_SYSTEM_PROCESSOR arm64 CACHE STRING "When not cross-compiling, this variable has the same value as the ``CMAKE_HOST_SYSTEM_PROCESSOR`` variable.")
            else()
                set(CMAKE_SYSTEM_PROCESSOR "${CMAKE_HOST_SYSTEM_PROCESSOR}" CACHE STRING "When not cross-compiling, this variable has the same value as the ``CMAKE_HOST_SYSTEM_PROCESSOR`` variable.")
            endif()
        endif()

        if(DEFINED CMAKE_SYSTEM_VERSION)
            set(CMAKE_SYSTEM_VERSION "${CMAKE_SYSTEM_VERSION}" CACHE STRING "The version of the operating system for which CMake is to build." FORCE)
        endif()

        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
            if(CMAKE_SYSTEM_PROCESSOR STREQUAL CMAKE_HOST_SYSTEM_PROCESSOR)
                set(CMAKE_CROSSCOMPILING OFF CACHE STRING "Intended to indicate whether CMake is cross compiling, but note limitations discussed below.")
            elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "ARM64")
                # arm64 macOS can run x64 binaries
                set(CMAKE_CROSSCOMPILING OFF CACHE STRING "Intended to indicate whether CMake is cross compiling, but note limitations discussed below.")
            endif()

            if(NOT DEFINED CMAKE_SYSTEM_VERSION)
                set(CMAKE_SYSTEM_VERSION "${CMAKE_HOST_SYSTEM_VERSION}" CACHE STRING "The version of the operating system for which CMake is to build.")
            endif()
        endif()

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS_INIT " -fPIC ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS_INIT " -fPIC ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG_INIT " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG_INIT " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE_INIT " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE_INIT " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif()
    endif()
    # End of OSX toolchain.

elseif(TARGET_IS_IOS)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/ios.cmake")
    message(STATUS "Using toolchain: iOS")
elseif(TARGET_IS_FREEBSD)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/freebsd.cmake")
    if(NOT _FREEBSD_TOOLCHAIN)
        set(_FREEBSD_TOOLCHAIN 1)
        message(STATUS "Using toolchain: FreeBSD")
        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "FreeBSD")
            set(CMAKE_CROSSCOMPILING OFF CACHE BOOL "")
        endif()
        set(CMAKE_SYSTEM_NAME FreeBSD CACHE STRING "")

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS_INIT " -fPIC ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS_INIT " -fPIC ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG_INIT " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG_INIT " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE_INIT " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE_INIT " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif()
    endif()
    # End of FreeBSD toolchain.

elseif(TARGET_IS_OPENBSD)
    # set(TOOLCHAIN_FILE "${TOOLCHAIN_FILES_DIR}/openbsd.cmake")
    if(NOT _OPENBSD_TOOLCHAIN)
        set(_OPENBSD_TOOLCHAIN 1)
        message(STATUS "Loading toolchain: OpenBSD")

        if(CMAKE_HOST_SYSTEM_NAME STREQUAL "OpenBSD")
            set(CMAKE_CROSSCOMPILING OFF CACHE BOOL "")
        endif()
        set(CMAKE_SYSTEM_NAME OpenBSD CACHE STRING "")

        if(NOT DEFINED CMAKE_CXX_COMPILER)
            set(CMAKE_CXX_COMPILER "/usr/bin/clang++")
        endif()
        if(NOT DEFINED CMAKE_C_COMPILER)
            set(CMAKE_C_COMPILER "/usr/bin/clang")
        endif()

        get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
        if(NOT _CMAKE_IN_TRY_COMPILE)
            string(APPEND CMAKE_C_FLAGS_INIT " -fPIC ${VCPKG_C_FLAGS} ")
            string(APPEND CMAKE_CXX_FLAGS_INIT " -fPIC ${VCPKG_CXX_FLAGS} ")
            string(APPEND CMAKE_C_FLAGS_DEBUG_INIT " ${VCPKG_C_FLAGS_DEBUG} ")
            string(APPEND CMAKE_CXX_FLAGS_DEBUG_INIT " ${VCPKG_CXX_FLAGS_DEBUG} ")
            string(APPEND CMAKE_C_FLAGS_RELEASE_INIT " ${VCPKG_C_FLAGS_RELEASE} ")
            string(APPEND CMAKE_CXX_FLAGS_RELEASE_INIT " ${VCPKG_CXX_FLAGS_RELEASE} ")

            string(APPEND CMAKE_SHARED_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_INIT " ${VCPKG_LINKER_FLAGS} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_DEBUG_INIT " ${VCPKG_LINKER_FLAGS_DEBUG} ")
            string(APPEND CMAKE_SHARED_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
            string(APPEND CMAKE_EXE_LINKER_FLAGS_RELEASE_INIT " ${VCPKG_LINKER_FLAGS_RELEASE} ")
        endif(NOT _CMAKE_IN_TRY_COMPILE)
    endif(NOT _OPENBSD_TOOLCHAIN)
    # End of OpenBSD toolchain.

elseif(TARGET_IS_EMSCRIPTEN)
    # set(TOOLCHAIN_FILE "${EMSCRIPTEN_ROOT}/cmake/Modules/Platform/Emscripten.cmake")
    message(STATUS "Loading toolchain: Emscripten")
    include("${EMSCRIPTEN_ROOT}/cmake/Modules/Platform/Emscripten.cmake")
    # End of WebAssembly toolchain.
endif()


# Determine whether the toolchain is loaded during a try-compile configuration
get_property(TOOLCHAIN_CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE)

if(USE_TOOLCHAIN)
    cmake_policy(POP)
    message(STATUS "Toolchain returning as expected.")
    return()
endif()

function(_add_executable)
    add_executable(${ARGS})
endfunction()

function(_add_library)
    add_library(${ARGS})
endfunction()

#If CMake does not have a mapping for MinSizeRel and RelWithDebInfo in imported targets
#it will map those configuration to the first valid configuration in CMAKE_CONFIGURATION_TYPES or the targets IMPORTED_CONFIGURATIONS.
#In most cases this is the debug configuration which is wrong.
# if(NOT DEFINED CMAKE_MAP_IMPORTED_CONFIG_MINSIZEREL)
#     set(CMAKE_MAP_IMPORTED_CONFIG_MINSIZEREL "MinSizeRel;Release;")
#     if(VERBOSE)
#         message(STATUS "CMAKE_MAP_IMPORTED_CONFIG_MINSIZEREL set to MinSizeRel;Release;")
#     endif()
# endif()
# if(NOT DEFINED CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO)
#     set(CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO "RelWithDebInfo;Release;")
#     if(VERBOSE)
#         message(STATUS "CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO set to RelWithDebInfo;Release;")
#     endif()
# endif()

######
# If tripet was passed in, use it and move on. Else, detect triplet arch from current generator...
if(TARGET_TRIPLET)

    # This is required since a user might do: 'set(VCPKG_TARGET_TRIPLET somevalue)' [no CACHE] before the first project() call
    # Latter within the toolchain file we do: 'set(VCPKG_TARGET_TRIPLET somevalue CACHE STRING "")' which
    # will otherwise override the user setting of VCPKG_TARGET_TRIPLET in the current scope of the toolchain since the CACHE value
    # did not exist previously. Since the value is newly created CMake will use the CACHE value within this scope since it is the more
    # recently created value in directory scope. This 'strange' behaviour only happens on the very first configure call since subsequent
    # configure call will see the user value as the more recent value. The same logic must be applied to all cache values within this file!
    # The FORCE keyword is required to ALWAYS lift the user provided/previously set value into a CACHE value.
    set(TARGET_TRIPLET "${TARGET_TRIPLET}" CACHE STRING "Target triplet (ex. x86-windows)" FORCE)

# If TARGET_TRIPLET wasn't passed in on the command line, search for reasonable defaults...
endif()

if(CMAKE_GENERATOR_PLATFORM MATCHES "^[Ww][Ii][Nn]32$")
    set(TARGET_TRIPLET_ARCH x86)
elseif(CMAKE_GENERATOR_PLATFORM MATCHES "^[Xx]64$")
    set(TARGET_TRIPLET_ARCH x64)
elseif(CMAKE_GENERATOR_PLATFORM MATCHES "^[Aa][Rr][Mm]$")
    set(TARGET_TRIPLET_ARCH arm)
elseif(CMAKE_GENERATOR_PLATFORM MATCHES "^[Aa][Rr][Mm]64$")
    set(TARGET_TRIPLET_ARCH arm64)
else()
    if(CMAKE_GENERATOR STREQUAL "Visual Studio 14 2015 Win64")
        set(TARGET_TRIPLET_ARCH x64)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 14 2015 ARM")
        set(TARGET_TRIPLET_ARCH arm)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 14 2015")
        set(TARGET_TRIPLET_ARCH x86)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 15 2017 Win64")
        set(TARGET_TRIPLET_ARCH x64)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 15 2017 ARM")
        set(TARGET_TRIPLET_ARCH arm)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 15 2017")
        set(TARGET_TRIPLET_ARCH x86)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 16 2019" AND CMAKE_VS_PLATFORM_NAME_DEFAULT STREQUAL "ARM64")
        set(TARGET_TRIPLET_ARCH arm64)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 16 2019")
        set(TARGET_TRIPLET_ARCH x64)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 17 2022" AND CMAKE_VS_PLATFORM_NAME_DEFAULT STREQUAL "ARM64")
        set(TARGET_TRIPLET_ARCH arm64)
    elseif(CMAKE_GENERATOR STREQUAL "Visual Studio 17 2022")
        set(TARGET_TRIPLET_ARCH x64)
    else()
        find_program(CL cl)
        if(CL MATCHES "amd64/cl.exe$" OR CL MATCHES "x64/cl.exe$")
            set(TARGET_TRIPLET_ARCH x64)
        elseif(CL MATCHES "arm/cl.exe$")
            set(TARGET_TRIPLET_ARCH arm)
        elseif(CL MATCHES "arm64/cl.exe$")
            set(TARGET_TRIPLET_ARCH arm64)
        elseif(CL MATCHES "bin/cl.exe$" OR CL MATCHES "x86/cl.exe$")
            set(TARGET_TRIPLET_ARCH x86)
        elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin" AND DEFINED CMAKE_SYSTEM_NAME AND NOT CMAKE_SYSTEM_NAME STREQUAL "Darwin")
            list(LENGTH OSX_ARCHITECTURES OSX_ARCH_COUNT)
            if(OSX_ARCH_COUNT EQUAL "0")
                message(WARNING "Unable to determine target architecture. "
                                "Consider providing a value for the OSX_ARCHITECTURES cache variable. "
                                "Continuing without toolchain.")
                set(USE_TOOLCHAIN ON)
                cmake_policy(POP)
                message(STATUS "Toolchain returning at line ${CMAKE_CURRENT_LIST_LINE}")
                return()
            endif()

            if(OSX_ARCH_COUNT GREATER "1")
                message(WARNING "Detected more than one target architecture. Using the first one.")
            endif()
            list(GET CMAKE_OSX_ARCHITECTURES "0" OSX_TARGET_ARCH)
            if(OSX_TARGET_ARCH STREQUAL "arm64")
                set(TARGET_TRIPLET_ARCH arm64)
            elseif(OSX_TARGET_ARCH STREQUAL "arm64s")
                set(TARGET_TRIPLET_ARCH arm64s)
            elseif(OSX_TARGET_ARCH STREQUAL "armv7s")
                set(TARGET_TRIPLET_ARCH armv7s)
            elseif(OSX_TARGET_ARCH STREQUAL "armv7")
                set(TARGET_TRIPLET_ARCH arm)
            elseif(OSX_TARGET_ARCH STREQUAL "x86_64")
                set(TARGET_TRIPLET_ARCH x64)
            elseif(OSX_TARGET_ARCH STREQUAL "i386")
                set(TARGET_TRIPLET_ARCH x86)
            else()
                message(WARNING "Unable to determine target architecture, continuing without toolchain.")
                set(USE_TOOLCHAIN ON)
                cmake_policy(POP)
                message(STATUS "Toolchain returning at line ${CMAKE_CURRENT_LIST_LINE}")
                return()
            endif()
        elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x86_64" OR
               CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "AMD64" OR
                # CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x64" OR
               CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "amd64")
            set(TARGET_TRIPLET_ARCH x64)
        elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "s390x")
            set(TARGET_TRIPLET_ARCH s390x)
        elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(TARGET_TRIPLET_ARCH ppc64le)
        elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "armv7l")
            set(TARGET_TRIPLET_ARCH arm)
        elseif(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "^(aarch64|arm64|ARM64)$")
            set(TARGET_TRIPLET_ARCH arm64)
	elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "riscv32")
	    set(TARGET_TRIPLET_ARCH riscv32)
	elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "riscv64")
	    set(TARGET_TRIPLET_ARCH riscv64)
        else()
            if(TOOLCHAIN_CMAKE_IN_TRY_COMPILE)
                message(STATUS "Unable to determine target architecture.")
            else()
                message(WARNING "Unable to determine target architecture.")
            endif()
            set(USE_TOOLCHAIN ON)
            cmake_policy(POP)
            message(STATUS "Toolchain returning at line ${CMAKE_CURRENT_LIST_LINE}")
            return()
        endif()
    endif()
endif()


#######

# Set target triplet platform from deduced CMake system name...
if(CMAKE_SYSTEM_NAME STREQUAL "WindowsStore" OR CMAKE_SYSTEM_NAME STREQUAL "WindowsPhone")
    set(TARGET_TRIPLET_PLATFORM uwp)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux" OR (NOT CMAKE_SYSTEM_NAME AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux"))
    set(TARGET_TRIPLET_PLATFORM linux)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin" OR (NOT CMAKE_SYSTEM_NAME AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin"))
    set(TARGET_TRIPLET_PLATFORM osx)
elseif(CMAKE_SYSTEM_NAME STREQUAL "iOS")
    set(TARGET_TRIPLET_PLATFORM ios)
elseif(MINGW OR (CMAKE_SYSTEM_NAME OR CMAKE_HOST_SYSTEM_NAME STREQUAL "MSYS"))
    set(TARGET_TRIPLET_PLATFORM mingw-dynamic)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows" OR (NOT CMAKE_SYSTEM_NAME AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows"))
    if(XBOX_CONSOLE_TARGET STREQUAL "scarlett")
        set(TARGET_TRIPLET_PLATFORM xbox-scarlett)
    elseif(XBOX_CONSOLE_TARGET STREQUAL "xboxone")
        set(TARGET_TRIPLET_PLATFORM xbox-xboxone)
    else()
        set(TARGET_TRIPLET_PLATFORM windows)
    endif()
elseif(CMAKE_SYSTEM_NAME STREQUAL "FreeBSD" OR (NOT CMAKE_SYSTEM_NAME AND CMAKE_HOST_SYSTEM_NAME STREQUAL "FreeBSD"))
    set(TARGET_TRIPLET_PLATFORM freebsd)
endif()

if(EMSCRIPTEN)
    set(TARGET_TRIPLET_ARCH wasm32)
    set(TARGET_TRIPLET_PLATFORM emscripten)
endif()

set(TARGET_TRIPLET_ARCH "${TARGET_TRIPLET_ARCH}" CACHE STRING "")
set(TARGET_TRIPLET_PLATFORM "${TARGET_TRIPLET_PLATFORM}" CACHE STRING "")
set(TARGET_TRIPLET "${TARGET_TRIPLET_ARCH}-${TARGET_TRIPLET_PLATFORM}" CACHE STRING "Target triplet (ex. x86-windows)")

message(STATUS "TARGET_TRIPLET = ${TARGET_TRIPLET}")
message(STATUS "TARGET_TRIPLET_ARCH = ${TARGET_TRIPLET_ARCH}")
message(STATUS "TARGET_TRIPLET_PLATFORM = ${TARGET_TRIPLET_PLATFORM}")

# Set target (triplet?) architecture from detected target triplet...
if(TARGET_TRIPLET STREQUAL "x64-windows-dynamic" OR TARGET_TRIPLET STREQUAL "x64-windows")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-windows.cmake")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
elseif(TARGET_TRIPLET STREQUAL "x64-windows-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-windows-static.cmake")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "x64-windows-static-md")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x64-windows-static-md.cmake")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "x86-windows-dynamic" OR TARGET_TRIPLET STREQUAL "x86-windows")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x86-windows.cmake")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
elseif(TARGET_TRIPLET STREQUAL "x86-windows-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x86-windows-static.cmake")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "x86-windows-static-md")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x86-windows-static-md.cmake")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "arm64-windows-dynamic" OR TARGET_TRIPLET STREQUAL "arm64-windows")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/arm64-windows.cmake")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
elseif(TARGET_TRIPLET STREQUAL "arm64-windows-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/arm64-windows-static.cmake")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "arm64-windows-static-md")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/arm64-windows-static-md.cmake")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "arm-windows-dynamic" OR TARGET_TRIPLET STREQUAL "arm-windows")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/arm-windows.cmake")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
elseif(TARGET_TRIPLET STREQUAL "arm-windows-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/arm-windows-static.cmake")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
elseif(TARGET_TRIPLET STREQUAL "arm-windows-static-md")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/arm-windows-static-md.cmake")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)

    # Linux triplets
elseif(TARGET_TRIPLET STREQUAL "x64-linux-dynamic" OR TARGET_TRIPLET STREQUAL "x64-linux") #this is not correct...
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-linux.cmake")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "x64-linux-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-linux-static.cmake")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "x86-linux-dynamic" OR TARGET_TRIPLET STREQUAL "x86-linux")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x86-linux.cmake")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "x86-linux-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-linux-static.cmake")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "arm-linux-dynamic" OR TARGET_TRIPLET STREQUAL "arm-linux")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/x64-linux.cmake")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "arm-linux-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/arm-linux-static.cmake")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "arm64-linux-dynamic" OR TARGET_TRIPLET STREQUAL "arm64-linux")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x86-linux.cmake")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "arm64-linux-static")
    # set(TRIPLET_FILE "${TRIPLET_FILES_DIR}/community/x64-linux-static.cmake")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)

    # Darwin triplets
elseif(TARGET_TRIPLET STREQUAL "x64-osx-static" OR TARGET_TRIPLET STREQUAL "x64-osx") #inverted defaults for osx...
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES x86_64)
elseif(TARGET_TRIPLET STREQUAL "x64-osx-dynamic")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES x86_64)
elseif(TARGET_TRIPLET STREQUAL "x86-osx-static" OR TARGET_TRIPLET STREQUAL "x86-osx")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES x86_64)
elseif(TARGET_TRIPLET STREQUAL "x86-osx-dynamic")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES x86_64)
elseif(TARGET_TRIPLET STREQUAL "arm64-osx-static" OR TARGET_TRIPLET STREQUAL "arm64-osx")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES arm64)
elseif(TARGET_TRIPLET STREQUAL "arm64-osx-dynamic")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME Darwin)
    set(OSX_ARCHITECTURES arm64)
    # On macOS, two architecture are supported: x86_64 is the architecture of Intel's 64-bit CPUs, sometimes also simply referred to as x64. It is the architecture for all Intel Macs shipped between 2005 and 2021. arm64 is the architecture used by newer Macs built on Apple Silicon, shipped in late 2020 and beyond.

    # MinGW triplets
elseif(TARGET_TRIPLET STREQUAL "x64-mingw-dynamic" OR TARGET_TRIPLET STREQUAL "x64-mingw")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
    # set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)
elseif(TARGET_TRIPLET STREQUAL "x64-mingw-static")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
elseif(TARGET_TRIPLET STREQUAL "x86-mingw-dynamic" OR TARGET_TRIPLET STREQUAL "x86-mingw")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
    # set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)
elseif(TARGET_TRIPLET STREQUAL "x86-mingw-static")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
elseif(TARGET_TRIPLET STREQUAL "arm64-mingw-dynamic" OR TARGET_TRIPLET STREQUAL "arm64-mingw")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
    # set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)
elseif(TARGET_TRIPLET STREQUAL "arm64-mingw-static")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
elseif(TARGET_TRIPLET STREQUAL "arm-mingw-dynamic" OR TARGET_TRIPLET STREQUAL "arm-mingw")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)
    # set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)
elseif(TARGET_TRIPLET STREQUAL "arm-mingw-static")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME MinGW)
    # set(VCPKG_ENV_PASSTHROUGH PATH)

    # Misc. triplets
elseif(TARGET_TRIPLET STREQUAL "x64-freebsd")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME FreeBSD)
elseif(TARGET_TRIPLET STREQUAL "x86-freebsd")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME FreeBSD)
elseif(TARGET_TRIPLET STREQUAL "x64-openbsd") # No x86 OpenBSD support?
    # Use with VCPKG_FORCE_SYSTEM_BINARIES=1 ./vcpkg install brotli
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME OpenBSD)
elseif(TARGET_TRIPLET STREQUAL "ppc64le-linux")
    set(TARGET_TRIPLET_ARCH ppc64le)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "riscv32-linux")
    set(TARGET_TRIPLET_ARCH riscv32)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "riscv64-linux")
    set(TARGET_TRIPLET_ARCH riscv64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "s390x-linux")
    set(TARGET_TRIPLET_ARCH s390x)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Linux)
elseif(TARGET_TRIPLET STREQUAL "x86-windows-v120")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(PLATFORM_TOOLSET "v120")
    # set(VCPKG_DEP_INFO_OVERRIDE_VARS "v120")

    # uwp triplets
elseif(TARGET_TRIPLET STREQUAL "x64-uwp-dynamic" OR TARGET_TRIPLET STREQUAL "x64-uwp") # No 'static' CRT for uwp targets...
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME WindowsStore)
    set(CMAKE_SYSTEM_VERSION 10.0)
elseif(TARGET_TRIPLET STREQUAL "x64-uwp-static-md")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME WindowsStore)
    set(CMAKE_SYSTEM_VERSION 10.0)
elseif(TARGET_TRIPLET STREQUAL "x686-uwp-dynamic" OR TARGET_TRIPLET STREQUAL "x86-uwp")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(CMAKE_SYSTEM_NAME WindowsStore)
    set(CMAKE_SYSTEM_VERSION 10.0)
elseif(TARGET_TRIPLET STREQUAL "x86-uwp-static-md")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME WindowsStore)
    set(CMAKE_SYSTEM_VERSION 10.0)

    # android triplets
elseif(TARGET_TRIPLET STREQUAL "x64-android")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(MAKEFILE_BUILD_TRIPLET "--host=x86_64-linux-android")
    set(ANDROID_ABI x86_64)
elseif(TARGET_TRIPLET STREQUAL "x86-android")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(MAKEFILE_BUILD_TRIPLET "--host=x86_64-linux-android")
    set(ANDROID_ABI x86)
elseif(TARGET_TRIPLET STREQUAL "arm64-android")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(MAKEFILE_BUILD_TRIPLET "--host=aarch64-linux-android")
    set(ANDROID_ABI arm64-v8a)
elseif(TARGET_TRIPLET STREQUAL "arm-android")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(MAKEFILE_BUILD_TRIPLET "--host=armv7a-linux-androideabi")
    set(ANDROID_ABI armeabi-v7a)
    set(ANDROID_ARM_NEON OFF)
elseif(TARGET_TRIPLET STREQUAL "arm-neon-android")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(MAKEFILE_BUILD_TRIPLET "--host=armv7a-linux-androideabi")
    set(ANDROID_ABI armeabi-v7a)
    set(ANDROID_ARM_NEON ON)
elseif(TARGET_TRIPLET STREQUAL "armv6-android")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE static)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Android)
    set(ANDROID_ABI armeabi)
    set(ANDROID_ARM_MODE arm)

    # iOS triplets
elseif(TARGET_TRIPLET STREQUAL "x64-ios")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME iOS)
elseif(TARGET_TRIPLET STREQUAL "x86-ios")
    set(TARGET_TRIPLET_ARCH x86)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME iOS)
elseif(TARGET_TRIPLET STREQUAL "arm64-ios")
    set(TARGET_TRIPLET_ARCH arm64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME iOS)
elseif(TARGET_TRIPLET STREQUAL "arm-ios")
    set(TARGET_TRIPLET_ARCH arm)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME iOS)

    # Xbox triplets
elseif(TARGET_TRIPLET STREQUAL "x64-xbox-xboxone-dynamic" OR TARGET_TRIPLET STREQUAL "x64-xbox-xboxone")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(XBOX_CONSOLE_TARGET xboxone)
elseif(TARGET_TRIPLET STREQUAL "x64-xbox-xboxone-static")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(XBOX_CONSOLE_TARGET xboxone)
elseif(TARGET_TRIPLET STREQUAL "x64-xbox-scarlett-dynamic" OR TARGET_TRIPLET STREQUAL "x64-xbox-scarlett")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE dynamic)
    set(XBOX_CONSOLE_TARGET scarlett)
elseif(TARGET_TRIPLET STREQUAL "x64-xbox-scarlett-static")
    set(TARGET_TRIPLET_ARCH x64)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(XBOX_CONSOLE_TARGET scarlett)

elseif(TARGET_TRIPLET STREQUAL "wasm32-emscripten")
    # set(VCPKG_ENV_PASSTHROUGH_UNTRACKED EMSCRIPTEN_ROOT EMSDK PATH)
    set(TARGET_TRIPLET_ARCH wasm32)
    set(CRT_LINKAGE dynamic)
    set(LIBRARY_LINKAGE static)
    set(CMAKE_SYSTEM_NAME Emscripten)

    # end vcpkg-supported triplets

else()
    message(FATAL_ERROR "Triplet not defined (or found?)")
endif()

if(DEFINED TARGET_TRIPLET_ARCH)
    set(TARGET_TRIPLET_ARCH "${TARGET_TRIPLET_ARCH}" CACHE STRING "")
endif()
if(DEFINED CRT_LINKAGE)
    set(CRT_LINKAGE "${CRT_LINKAGE}" CACHE STRING "")
endif()
if(DEFINED LIBRARY_LINKAGE)
    set(LIBRARY_LINKAGE "${LIBRARY_LINKAGE}" CACHE STRING "")
endif()

if(DEFINED OSX_ARCHITECTURES)
    set(OSX_ARCHITECTURES "${OSX_ARCHITECTURES}" CACHE STRING "OSX Architectures available.")
    # set(CMAKE_OSX_ARCHITECTURES "${OSX_ARCHITECTURES}")
endif()
if(DEFINED ANDROID_ABI)
    set(ANDROID_ABI "${ANDROID_ABI}" CACHE STRING "Android binary interface to use.")
    # set(CMAKE_ANDROID_API "${ANDROID_ABI}")
endif()
if(DEFINED ANDROID_ARM_NEON)
    set(ANDROID_ARM_NEON "${ANDROID_ARM_NEON}" CACHE BOOL "True if using Neon for arm-based android targets.")
    set(CMAKE_ANDROID_ARM_NEON "${ANDROID_ARM_NEON}" CACHE STRING "When :`Cross Compiling for Android` and ``CMAKE_ANDROID_ARCH_ABI`` is set to ``armeabi-v7a`` set ``CMAKE_ANDROID_ARM_NEON`` to ``ON`` to target ARM NEON devices.")
endif()
if(DEFINED ANDROID_ARM_MODE)
    set(ANDROID_ARM_MODE "${ANDROID_ARM_MODE}" CACHE STRING "Mode to use for arm-based android targets.")
    set(CMAKE_ANDROID_ARM_MODE "${ANDROID_ARM_MODE}" CACHE STRING "When :`Cross Compiling for Android` and ``CMAKE_ANDROID_ARCH_ABI`` is set to one of the ``armeabi`` architectures, set ``CMAKE_ANDROID_ARM_MODE`` to ``ON`` to target 32-bit ARM processors (``-marm``).")
endif()
# if(DEFINED MAKEFILE_BUILD_TRIPLET)
#     list(APPEND CMAKE_USER_MAKE_RULES_OVERRIDE "${MAKEFILE_BUILD_TRIPLET}")
# endif()
if(XBOX_CONSOLE_TARGET STREQUAL "xboxone" OR XBOX_CONSOLE_TARGET STREQUAL "xboxone")
    set(XBOX_CONSOLE_TARGET "${XBOX_CONSOLE_TARGET}" CACHE STRING "Xbox console target. Can be 'xboxone' or 'scarlett'.")
endif()
if(TARGET_TRIPLET STREQUAL "wasm32-emscripten")
    # set(VCPKG_ENV_PASSTHROUGH_UNTRACKED EMSCRIPTEN_ROOT EMSDK PATH)

    if(NOT DEFINED ENV{EMSCRIPTEN_ROOT})
        find_path(EMSCRIPTEN_ROOT "emcc")
    else()
        set(EMSCRIPTEN_ROOT "$ENV{EMSCRIPTEN_ROOT}")
    endif()

    if(NOT EMSCRIPTEN_ROOT)
        if(NOT DEFINED ENV{EMSDK})
            message(FATAL_ERROR "The emcc compiler not found in PATH")
        endif()
        set(EMSCRIPTEN_ROOT "$ENV{EMSDK}/upstream/emscripten")
    endif()

    if(NOT EXISTS "${EMSCRIPTEN_ROOT}/cmake/Modules/Platform/Emscripten.cmake")
        message(FATAL_ERROR "Emscripten.cmake toolchain file not found")
    endif()
endif()





# set(TRIPLET_FILE "${TRIPLET_FILE}" CACHE FILEPATH "The triplet file." FORCE)
# if(TARGET_TRIPLET NOT STREQUAL "")
#     include("${TRIPLET_FILE}")
# else()
#     message(FATAL_ERROR "No triplet specified (or found?)")
# endif()

###################################################

#Helper variable to identify the Target system. VCPKG_TARGET_IS_<targetname>
if (NOT DEFINED CMAKE_SYSTEM_NAME OR CMAKE_SYSTEM_NAME STREQUAL "")
    set(TARGET_IS_WINDOWS ON)

    if(DEFINED XBOX_CONSOLE_TARGET AND NOT "${XBOX_CONSOLE_TARGET}" STREQUAL "")
        set(TARGET_IS_XBOX ON)
    endif()
elseif(CMAKE_SYSTEM_NAME STREQUAL "WindowsStore")
    set(TARGET_IS_WINDOWS ON)
    set(TARGET_IS_UWP ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set(TARGET_IS_OSX ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "iOS")
    set(TARGET_IS_IOS ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set(TARGET_IS_LINUX ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Android")
    set(TARGET_IS_ANDROID ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
    set(TARGET_IS_FREEBSD ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
    set(TARGET_IS_OPENBSD ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "MinGW")
    set(TARGET_IS_WINDOWS ON)
    set(TARGET_IS_MINGW ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
    set(TARGET_IS_EMSCRIPTEN ON)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows") # Needed since this option isn't specified above...
    set(TARGET_IS_WINDOWS ON)
endif()

#Helper variables to identify the host system name
if (CMAKE_HOST_WIN32)
    set(HOST_IS_WINDOWS ON)
elseif (CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
    set(HOST_IS_OSX ON)
elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
    set(HOST_IS_LINUX ON)
elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "FreeBSD")
    set(HOST_IS_FREEBSD ON)
elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "OpenBSD")
    set(HOST_IS_OPENBSD ON)
endif()

set(CMAKE_HOST_SYSTEM_NAME "${CMAKE_HOST_SYSTEM_NAME}" CACHE STRING "Name of the OS CMake is running on.")

#Helper variable to identify the host path separator.
if(CMAKE_HOST_WIN32)
    set(HOST_PATH_SEPARATOR ";")
elseif(CMAKE_HOST_UNIX)
    set(HOST_PATH_SEPARATOR ":")
endif()

#Helper variables to identify executables on host/target
if(CMAKE_HOST_WIN32)
    set(HOST_EXECUTABLE_SUFFIX ".exe")
else()
    set(HOST_EXECUTABLE_SUFFIX "")
endif()
#set(CMAKE_EXECUTABLE_SUFFIX ${VCPKG_HOST_EXECUTABLE_SUFFIX}) not required by find_program

#Helper variables to identify bundles on host/target
if(HOST_IS_OSX)
    set(HOST_BUNDLE_SUFFIX ".app")
else()
    set(HOST_BUNDLE_SUFFIX "")
endif()

########################### Targets

if(TARGET_IS_WINDOWS)
    set(TARGET_EXECUTABLE_SUFFIX ".exe")
else()
    set(TARGET_EXECUTABLE_SUFFIX "")
endif()

if(TARGET_IS_OSX OR TARGET_IS_IOS)
    set(TARGET_BUNDLE_SUFFIX ".app")
else()
    set(TARGET_BUNDLE_SUFFIX "")
endif()

#Helper variables for libraries
if(TARGET_IS_MINGW)
    set(TARGET_STATIC_LIBRARY_SUFFIX ".a")
    set(TARGET_IMPORT_LIBRARY_SUFFIX ".dll.a")
    set(TARGET_SHARED_LIBRARY_SUFFIX ".dll")
    set(TARGET_STATIC_LIBRARY_PREFIX "lib")
    set(TARGET_SHARED_LIBRARY_PREFIX "lib")
    set(TARGET_IMPORT_LIBRARY_PREFIX "lib")
    set(FIND_LIBRARY_SUFFIXES ".dll" ".dll.a" ".a" ".lib")
    set(FIND_LIBRARY_PREFIXES "lib" "")
elseif(TARGET_IS_WINDOWS)
    set(TARGET_STATIC_LIBRARY_SUFFIX ".lib")
    set(TARGET_IMPORT_LIBRARY_SUFFIX ".lib")
    set(TARGET_SHARED_LIBRARY_SUFFIX ".dll")
    set(TARGET_IMPORT_LIBRARY_SUFFIX ".lib")
    set(TARGET_STATIC_LIBRARY_PREFIX "")
    set(TARGET_SHARED_LIBRARY_PREFIX "")
    set(TARGET_IMPORT_LIBRARY_PREFIX "")
    set(FIND_LIBRARY_SUFFIXES ".lib" ".dll") #This is a slight modification to CMakes value which does not include ".dll".
    set(FIND_LIBRARY_PREFIXES "" "lib") #This is a slight modification to CMakes value which does not include "lib".
elseif(TARGET_IS_OSX)
    set(TARGET_STATIC_LIBRARY_SUFFIX ".a")
    set(TARGET_IMPORT_LIBRARY_SUFFIX "")
    set(TARGET_SHARED_LIBRARY_SUFFIX ".dylib")
    set(TARGET_STATIC_LIBRARY_PREFIX "lib")
    set(TARGET_SHARED_LIBRARY_PREFIX "lib")
    set(FIND_LIBRARY_SUFFIXES ".tbd" ".dylib" ".so" ".a")
    set(FIND_LIBRARY_PREFIXES "lib" "")
else()
    set(TARGET_STATIC_LIBRARY_SUFFIX ".a")
    set(TARGET_IMPORT_LIBRARY_SUFFIX "")
    set(TARGET_SHARED_LIBRARY_SUFFIX ".so")
    set(TARGET_STATIC_LIBRARY_PREFIX "lib")
    set(TARGET_SHARED_LIBRARY_PREFIX "lib")
    set(FIND_LIBRARY_SUFFIXES ".so" ".a")
    set(FIND_LIBRARY_PREFIXES "lib" "")
endif()

set(TARGET_STATIC_LIBRARY_SUFFIX "${TARGET_STATIC_LIBRARY_SUFFIX}" CACHE STRING "The suffix for static libraries that you link to.")
set(TARGET_SHARED_LIBRARY_SUFFIX "${TARGET_SHARED_LIBRARY_SUFFIX}" CACHE STRING "The suffix for shared libraries that you link to.")
set(TARGET_IMPORT_LIBRARY_SUFFIX "${TARGET_IMPORT_LIBRARY_SUFFIX}" CACHE STRING "The suffix for import libraries that you link to.")
set(TARGET_STATIC_LIBRARY_PREFIX "${TARGET_STATIC_LIBRARY_PREFIX}" CACHE STRING "The prefix for static libraries that you link to.")
set(TARGET_SHARED_LIBRARY_PREFIX "${TARGET_SHARED_LIBRARY_PREFIX}" CACHE STRING "The prefix for shared libraries that you link to.")
set(TARGET_IMPORT_LIBRARY_PREFIX "${TARGET_IMPORT_LIBRARY_PREFIX}" CACHE STRING "The prefix for import libraries that you link to.")

set(FIND_LIBRARY_SUFFIXES "${FIND_LIBRARY_SUFFIXES}" CACHE STRING "Suffixes to append when looking for libraries.") # Required by find_library
set(FIND_LIBRARY_PREFIXES "${FIND_LIBRARY_PREFIXES}" CACHE STRING "Prefixes to prepend when looking for libraries.") # Required by find_library


#Setting these variables allows find_library to work in script mode and thus in portfiles!
#This allows us scale down on hardcoded target dependent paths in portfiles
set(CMAKE_STATIC_LIBRARY_SUFFIX "${TARGET_STATIC_LIBRARY_SUFFIX}")
set(CMAKE_SHARED_LIBRARY_SUFFIX "${TARGET_SHARED_LIBRARY_SUFFIX}")
set(CMAKE_IMPORT_LIBRARY_SUFFIX "${TARGET_IMPORT_LIBRARY_SUFFIX}")
set(CMAKE_STATIC_LIBRARY_PREFIX "${TARGET_STATIC_LIBRARY_PREFIX}")
set(CMAKE_SHARED_LIBRARY_PREFIX "${TARGET_SHARED_LIBRARY_PREFIX}")
set(CMAKE_IMPORT_LIBRARY_PREFIX "${TARGET_IMPORT_LIBRARY_PREFIX}")

set(CMAKE_FIND_LIBRARY_SUFFIXES "${FIND_LIBRARY_SUFFIXES}" CACHE INTERNAL "Suffixes to append when looking for libraries.") # Required by find_library
set(CMAKE_FIND_LIBRARY_PREFIXES "${FIND_LIBRARY_PREFIXES}" CACHE INTERNAL "Prefixes to prepend when looking for libraries.") # Required by find_library

# Append platform libraries to SYSTEM_LIBRARIES
# The variables are just appended to permit to custom triplets define the variable

# Platforms with libdl
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_OSX)
    list(APPEND SYSTEM_LIBRARIES dl)
endif()

# Platforms with libm
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_FREEBSD OR TARGET_IS_OPENBSD OR TARGET_IS_OSX OR TARGET_IS_MINGW)
    list(APPEND SYSTEM_LIBRARIES m)
endif()

# Platforms with pthread
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_OSX OR TARGET_IS_FREEBSD OR TARGET_IS_OPENBSD OR TARGET_IS_MINGW)
    list(APPEND SYSTEM_LIBRARIES pthread)
endif()

# Platforms with libstdc++
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_FREEBSD OR TARGET_IS_OPENBSD OR TARGET_IS_MINGW)
    list(APPEND SYSTEM_LIBRARIES [[stdc\+\+]])
endif()

# Platforms with libc++
if(TARGET_IS_OSX)
    list(APPEND SYSTEM_LIBRARIES [[c\+\+]])
endif()

# Platforms with librt
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_OSX OR TARGET_IS_FREEBSD OR TARGET_IS_MINGW)
    list(APPEND SYSTEM_LIBRARIES rt)
endif()

# Platforms with GCC libs
if(TARGET_IS_LINUX OR TARGET_IS_ANDROID OR TARGET_IS_OSX OR TARGET_IS_FREEBSD OR TARGET_IS_OPENBSD OR TARGET_IS_MINGW)
    list(APPEND SYSTEM_LIBRARIES gcc)
    list(APPEND SYSTEM_LIBRARIES gcc_s)
endif()

# Platforms with system iconv
if(TARGET_IS_OSX)
    list(APPEND SYSTEM_LIBRARIES iconv)
endif()

# Windows system libs
if(TARGET_IS_WINDOWS)
    list(APPEND SYSTEM_LIBRARIES advapi32)
    list(APPEND SYSTEM_LIBRARIES bcrypt)
    list(APPEND SYSTEM_LIBRARIES dinput8)
    list(APPEND SYSTEM_LIBRARIES gdi32)
    list(APPEND SYSTEM_LIBRARIES imm32)
    list(APPEND SYSTEM_LIBRARIES oleaut32)
    list(APPEND SYSTEM_LIBRARIES ole32)
    list(APPEND SYSTEM_LIBRARIES psapi)
    list(APPEND SYSTEM_LIBRARIES secur32)
    list(APPEND SYSTEM_LIBRARIES setupapi)
    list(APPEND SYSTEM_LIBRARIES shell32)
    list(APPEND SYSTEM_LIBRARIES shlwapi)
    list(APPEND SYSTEM_LIBRARIES strmiids)
    list(APPEND SYSTEM_LIBRARIES user32)
    list(APPEND SYSTEM_LIBRARIES uuid)
    list(APPEND SYSTEM_LIBRARIES version)
    list(APPEND SYSTEM_LIBRARIES vfw32)
    list(APPEND SYSTEM_LIBRARIES winmm)
    list(APPEND SYSTEM_LIBRARIES wsock32)
    list(APPEND SYSTEM_LIBRARIES Ws2_32)
    list(APPEND SYSTEM_LIBRARIES wldap32)
    list(APPEND SYSTEM_LIBRARIES crypt32)
endif()


if(USE_TOOLCHAIN)
    cmake_policy(POP)
    message(STATUS "Toolchain returning at line ${CMAKE_CURRENT_LIST_LINE}")
    return()
endif()


string(COMPARE NOTEQUAL "${TARGET_TRIPLET}" "${HOST_TRIPLET}" CROSSCOMPILING)

cmake_policy(POP)

# Any policies applied to the below macros and functions appear to leak into consumers

function(add_executable)
    function_arguments(ARGS)
    _add_executable(${ARGS})
    set(target_name "${ARGV0}")

    list(FIND ARGV "IMPORTED" IMPORTED_IDX)
    list(FIND ARGV "ALIAS" ALIAS_IDX)
    list(FIND ARGV "MACOSX_BUNDLE" MACOSX_BUNDLE_IDX)
    if(IMPORTED_IDX EQUAL "-1" AND ALIAS_IDX EQUAL "-1")
        if(APPLOCAL_DEPS)
            if(TARGET_TRIPLET_PLATFORM MATCHES "windows|uwp|xbox")
                set_powershell_path()
                set(EXTRA_OPTIONS "")
                if(APPLOCAL_DEPS_SERIALIZED)
                    set(EXTRA_OPTIONS USES_TERMINAL)
                endif()
                add_custom_command(TARGET "${target_name}" POST_BUILD
                    COMMAND "${POWERSHELL_PATH}" -noprofile -executionpolicy Bypass -file "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/msbuild/applocal.ps1"
                        -targetBinary "$<TARGET_FILE:${target_name}>"
                        -installedDir "${CMAKE_INSTALL_PREFIX}/${TARGET_TRIPLET}$<$<CONFIG:Debug>:/debug>/bin"
                        -OutVariable out
                    VERBATIM
                    ${EXTRA_OPTIONS}
                )
            elseif(TARGET_TRIPLET_PLATFORM MATCHES "osx")
                if(NOT MACOSX_BUNDLE_IDX EQUAL "-1")
                    find_package(Python COMPONENTS Interpreter)
                    add_custom_command(TARGET "${target_name}" POST_BUILD
                        COMMAND "${Python_EXECUTABLE}" "./osx/applocal.py"
                            "$<TARGET_FILE:${target_name}>"
                            "${CMAKE_INSTALL_PREFIX}/${TARGET_TRIPLET}$<$<CONFIG:Debug>:/debug>"
                        VERBATIM
                    )
                endif()
            endif()
        endif()
        set_target_properties("${target_name}" PROPERTIES VS_USER_PROPS do_not_import_user.props)
        set_target_properties("${target_name}" PROPERTIES VS_GLOBAL_VcpkgEnabled false)
    endif()
endfunction()

function(add_library)
    function_arguments(ARGS)
    _add_library(${ARGS})
    set(target_name "${ARGV0}")

    list(FIND ARGS "IMPORTED" IMPORTED_IDX)
    list(FIND ARGS "INTERFACE" INTERFACE_IDX)
    list(FIND ARGS "ALIAS" ALIAS_IDX)
    if(IMPORTED_IDX EQUAL "-1" AND INTERFACE_IDX EQUAL "-1" AND ALIAS_IDX EQUAL "-1")
        get_target_property(IS_LIBRARY_SHARED "${target_name}" TYPE)
        if(APPLOCAL_DEPS AND TARGET_TRIPLET_PLATFORM MATCHES "windows|uwp|xbox" AND (IS_LIBRARY_SHARED STREQUAL "SHARED_LIBRARY" OR IS_LIBRARY_SHARED STREQUAL "MODULE_LIBRARY"))
            set_powershell_path()
            add_custom_command(TARGET "${target_name}" POST_BUILD
                COMMAND "${POWERSHELL_PATH}" -noprofile -executionpolicy Bypass -file "./msbuild/applocal.ps1"
                    -targetBinary "$<TARGET_FILE:${target_name}>"
                    -installedDir "${CMAKE_INSTALL_PREFIX}/${TARGET_TRIPLET}$<$<CONFIG:Debug>:/debug>/bin"
                    -OutVariable out
                    VERBATIM
            )
        endif()
        set_target_properties("${target_name}" PROPERTIES VS_USER_PROPS do_not_import_user.props)
        set_target_properties("${target_name}" PROPERTIES VS_GLOBAL_VcpkgEnabled false)
    endif()
endfunction()

cmake_policy(PUSH)
cmake_policy(VERSION 3.7.2)

# Don't change this var, it prevents cyclical includes :)
set(USE_TOOLCHAIN ON)

# set(Z_VCPKG_UNUSED "${CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION}")
# set(Z_VCPKG_UNUSED "${CMAKE_EXPORT_NO_PACKAGE_REGISTRY}")
# set(Z_VCPKG_UNUSED "${CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY}")
# set(Z_VCPKG_UNUSED "${CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY}")
# set(Z_VCPKG_UNUSED "${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP}")

# Propogate these values to try-compile configurations so the triplet and toolchain load
if(NOT TOOLCHAIN_CMAKE_IN_TRY_COMPILE)
    list(APPEND CMAKE_TRY_COMPILE_PLATFORM_VARIABLES
        TARGET_TRIPLET
        TARGET_TRIPLET_ARCH
        TARGET_TRIPLET_PLATFORM
        #APPLOCAL_DEPS - we can test for these individually below instead...
        #VCPKG_CHAINLOAD_TOOLCHAIN_FILE
        #Z_VCPKG_ROOT_DIR
    )
    if(DEFINED APPLOCAL_DEPS)
        list(APPEND CMAKE_TRY_COMPILE_PLATFORM_VARIABLES
            APPLOCAL_DEPS
        )
    endif()
endif()

if(CONFIG_HAS_FATAL_ERROR)
    message(FATAL_ERROR "${CONFIG_FATAL_ERROR}")
endif()

cmake_policy(POP)

message(STATUS "Toolchain file loaded.")

set(BUILD_INFO_FILE_PATH ${CMAKE_CURRENT_BINARY_DIR}/BUILD_INFO)
file(WRITE  ${BUILD_INFO_FILE_PATH} "CRTLinkage: ${CRT_LINKAGE}\n")
file(APPEND ${BUILD_INFO_FILE_PATH} "LibraryLinkage: ${LIBRARY_LINKAGE}\n")

if (DEFINED POLICY_DLLS_WITHOUT_LIBS)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyDLLsWithoutLIBs: ${POLICY_DLLS_WITHOUT_LIBS}\n")
endif()
if (DEFINED POLICY_DLLS_WITHOUT_EXPORTS)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyDLLsWithoutExports: ${POLICY_DLLS_WITHOUT_EXPORTS}\n")
endif()
if (DEFINED POLICY_DLLS_IN_STATIC_LIBRARY)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyDLLsInStaticLibrary: ${POLICY_DLLS_IN_STATIC_LIBRARY}\n")
endif()
if (DEFINED POLICY_MISMATCHED_NUMBER_OF_BINARIES)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyMismatchedNumberOfBinaries: ${POLICY_MISMATCHED_NUMBER_OF_BINARIES}\n")
endif()
if (DEFINED POLICY_EMPTY_PACKAGE)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyEmptyPackage: ${POLICY_EMPTY_PACKAGE}\n")
endif()
if (DEFINED POLICY_ONLY_RELEASE_CRT)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyOnlyReleaseCRT: ${POLICY_ONLY_RELEASE_CRT}\n")
endif()
if (DEFINED POLICY_ALLOW_OBSOLETE_MSVCRT)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyAllowObsoleteMsvcrt: ${POLICY_ALLOW_OBSOLETE_MSVCRT}\n")
endif()
if (DEFINED POLICY_EMPTY_INCLUDE_FOLDER)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyEmptyIncludeFolder: ${POLICY_EMPTY_INCLUDE_FOLDER}\n")
endif()
if (DEFINED POLICY_ALLOW_RESTRICTED_HEADERS)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyAllowRestrictedHeaders: ${POLICY_ALLOW_RESTRICTED_HEADERS}\n")
endif()
if (DEFINED POLICY_SKIP_DUMPBIN_CHECKS)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicySkipDumpbinChecks: ${POLICY_SKIP_DUMPBIN_CHECKS}\n")
endif()
if (DEFINED POLICY_SKIP_ARCHITECTURE_CHECK)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicySkipArchitectureCheck: ${POLICY_SKIP_ARCHITECTURE_CHECK}\n")
endif()
if (DEFINED POLICY_CMAKE_HELPER_PORT)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicyCmakeHelperPort: ${POLICY_CMAKE_HELPER_PORT}\n")
endif()
if (DEFINED POLICY_SKIP_ABSOLUTE_PATHS_CHECK)
    file(APPEND ${BUILD_INFO_FILE_PATH} "PolicySkipAbsolutePathsCheck: ${POLICY_SKIP_ABSOLUTE_PATHS_CHECK}\n")
endif()
if (DEFINED HEAD_VERSION)
    file(APPEND ${BUILD_INFO_FILE_PATH} "Version: ${HEAD_VERSION}\n")
endif()
